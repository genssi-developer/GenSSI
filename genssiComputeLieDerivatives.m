function [options,VectorLieDerivatives]=genssiComputeLieDerivatives(model,options)
    % genssiComputeLieDerivatives computes Lie derivatives of the
    %  output functions (model.H), the state vectors (model.X), and the
    %  initial conditions (model.IC) with respect to the equations
    %  (model.F) and controls (model.G)
    %
    % Parameters:
    %  model: model definition (struct)
    %  options: processing options (struct)
    %
    % Return values:
    %  options: processing options (struct)
    %  VectorLieDerivatives: a vector of all Lie derivatives
    %  
    fprintf(1,'*******************************\n');
    fprintf(1,'-> COMPUTE LIE DERIVATIVES\n');
    fprintf(1,'*******************************\n\n');
    h0=subs(model.H,model.X,model.IC);
    %Computes V0 and V1
    fprintf(1,'COMPUTING LIE DERIVATIVES OF ORDER 1\n');
    fprintf(1,'.................................................................\n');
    Rankdiff=[]; 
    Jac0 = model.F*jacobian(model.H,model.X).';
    v0=subs(Jac0,model.X,model.IC);
    Jac1 = model.G*jacobian(model.H,model.X).';
    v1=subs(Jac1,model.X,model.IC);
    LDer = [h0;v0;v1];
    % calculate 2D jacobian the way Maple does it
    JacParamC1=jacobian(reshape(LDer,[numel(LDer),1]),model.Par);
    RankSubJacobian1=rank(JacParamC1);
    j1=double(RankSubJacobian1);
    Rankdiff=[Rankdiff RankSubJacobian1];
    if j1==length(model.Par)
        disp(['->The rank of the Jacobian generated by 1 derivative is', ' ', num2str(j1),'.' ])
        fprintf(1,'.................................................................\n');
        disp('  ')
        LieDerivatives=[h0;v0;v1];
        VectorLieDerivatives=reshape(transpose(LieDerivatives),[1,numel(LieDerivatives)]);
        VectorLieDerivatives=genssiRemoveZeroElementsR(VectorLieDerivatives);
    else
        disp(['   ->The rank of the Jacobian generated by 1 derivative is',' ', num2str(j1),'.' ])
        fprintf(1,'.................................................................\n');
        disp('  ')
        Jac=[]; 
        Vector_ranks=[];
        %%% CASE WITHOUT CONTROL
        if model.Noc<1 
            for k = 1:model.Nder-1
                order=k+1;
                disp(['COMPUTING LIE DERIVATIVES OF ORDER', ' ', num2str(order)])
                disp('   ')
                fprintf(1,'.................................................................\n');
                [r,tilde]=size(Jac0);  
                Jac=[Jac;Jac0];
                Jac00=sym(zeros(size(Jac0))); % preallocate for speed
                for j=1:r
                   Jac00(j,:)=model.F*jacobian(Jac0(j,:),model.X).';
                end
                Jac0=Jac00;
%                 r=length(Jac0);
                Jac=[Jac; Jac00];    
                Jacs=subs(Jac,model.X,model.IC);
                % calculate 2D jacobian the way Maple does it
                LDer = [h0;v0;Jacs];
                JacParamC=jacobian(reshape(LDer,[numel(LDer),1]),model.Par);
                RankSubJacobian=rank(JacParamC);
                j2=double(RankSubJacobian);
                if j2==length(model.Par)
                    disp(['   ->The rank of the Jacobian generated by', ' ', num2str(order), ' derivatives is',' ',num2str(j2),'.' ])
                    break;
                else     
                    Vector_ranks=[Vector_ranks RankSubJacobian];
                    Rank=[Rankdiff Vector_ranks];
                    a=length(Rank);
                    diff=Rank(a)-Rank(a-1);
                    if diff==0
                        s2=RankSubJacobian+RankSubJacobian1;
                    else
                        s2=RankSubJacobian+diff;
                    end
                    s31=double(s2);
                    s3=min(s31,length(model.Par));
                    disp(['   ->The rank of the Jacobian generated by', ' ', num2str(order), ' derivatives is ', ' ', num2str(j2),'.' ])
                    disp(['   ->The rank of the next Jacobian is expected to be maximum', ' ', int2str(s3),'.'])
                    fprintf(1,'.................................................................\n');
                    disp('  ')
                end
            end
            LieDerivatives=subs([model.H;v0;Jac],model.X,model.IC);
            %Puts in order the components after each iteration 
            VectorLieDerivatives=reshape(transpose(LieDerivatives),[1,numel(LieDerivatives)]);
            VectorLieDerivatives=genssiRemoveZeroElementsR(VectorLieDerivatives);
        else  %%% CASE WITH CONTROL VARIABLES
%             q=[];
            Jac=[];
            Vector_ranks=[];
            %Computes all combinations of V0 and V1 of order k (the number of derivatives)
            for k = 1:model.Nder-1
                order=k+1;
                disp(['COMPUTING LIE DERIVATIVES OF ORDER', ' ', num2str(order)])
                fprintf(1,'.................................................................\n');
                for ii=1:model.Noc
                    Jac=[Jac;Jac0;Jac1];
                    [rx, tilde]=size(Jac);
                    Jac00=sym(zeros(size(Jac))); % preallocate for speed
                    Jac10=sym(zeros(size(Jac))); % preallocate for speed
                    for j=1:rx
                        Jac00(j,:) = model.F*jacobian(Jac(j,:),model.X).';
                        Jac10(j,:) = model.G(ii,:)*jacobian(Jac(j,:),model.X).';
                    end
                    Jac0=Jac00;
                    Jac1=Jac10;
%                     rx=length(Jac);
                    Jac=[Jac;Jac00;Jac10];
                end
                LDer=subs([model.H;v0;v1;Jac],model.X,model.IC);
                % calculate 2D jacobian the way Maple does it
                JacParamC=jacobian(reshape(LDer,[numel(LDer),1]),model.Par);
                RankSubJacobian=rank(JacParamC);
                j2=double(RankSubJacobian);
                if j2==length(model.Par)
                    disp(['   ->The rank of the Jacobian generated by', ' ', num2str(order), ' derivatives is', ' ', num2str(j2),'.' ])
                    break;
                else           
                    Vector_ranks=[Vector_ranks  RankSubJacobian];
                    Rank=[Rankdiff Vector_ranks];
                    a=length(Rank);
                    diff=Rank(a)-Rank(a-1);
                    if double(diff)==0
                        s2=RankSubJacobian*2;
                    else
                        s2=RankSubJacobian+diff;
                    end
                    s31=double(s2);
                    s3=min(s31,length(model.Par));
                    disp(['   ->The rank of the Jacobian generated by', ' ', num2str(order), ' derivatives is', ' ', num2str(j2),'.' ])
                    disp(['   ->The rank of the next Jacobian is expected to be maximum', ' ', int2str(s3),'.'])
                    fprintf(1,'.................................................................\n');
                    disp('  ')
                end
            end
        end  
        LieDerivatives=subs([model.H;v0;v1;Jac],model.X,model.IC);
        %Puts in order the components after each iteration 
        VectorLieDerivatives=reshape(transpose(LieDerivatives),[1,numel(LieDerivatives)]);
        VectorLieDerivatives=genssiRemoveZeroElementsR(VectorLieDerivatives);
    end
end



