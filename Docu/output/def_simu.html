<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>GenSSI: Model Definition &amp; Simulation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="GenSSI-logo.jpg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GenSSI
   &#160;<span id="projectnumber">2.0</span>
   </div>
   <div id="projectbrief">GenSSI V 2.0</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('def_simu.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Model Definition &amp; Simulation </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>In the following we will give a detailed overview how to specify models in GenSSI and how to call the code for analyzing the model. We use the Goodwin oscillator as an example.</p>
<h1><a class="anchor" id="definition"></a>
Model Definition</h1>
<p>This manual will guide the user to specify models in MATLAB. For example implementations, see the models in the example directory.</p>
<h2><a class="anchor" id="header"></a>
Header</h2>
<p>The model definition needs to be defined as a function which returns a struct with all symbolic definitions and options.</p>
<div class="fragment"><div class="line"><span class="keyword">function</span> [model] = Goodwin() </div></div><!-- fragment --><h2><a class="anchor" id="name"></a>
Name</h2>
<p>Give the model a name.</p>
<div class="fragment"><div class="line">model.Name = <span class="stringliteral">&#39;Goodwin&#39;</span>; </div></div><!-- fragment --><p>The name will be used to create a subdirectory in the Results directory where the results of analysis will be stored.</p>
<h2><a class="anchor" id="derivatives"></a>
Derivatives</h2>
<p>Set the number of derivatives to be calculated.</p>
<div class="fragment"><div class="line">model.Nder = 8; </div></div><!-- fragment --><h2><a class="anchor" id="variables"></a>
Variables</h2>
<p>Create the respective symbolic variables. The name of the symbolic variable can be chosen arbitrarily.</p>
<div class="fragment"><div class="line">syms x1 x2 x3 </div></div><!-- fragment --><p>Create the state vector containing all states:</p>
<div class="fragment"><div class="line">model.X = [x1 x2 x3]; </div></div><!-- fragment --><p>Define the number of variables.</p>
<div class="fragment"><div class="line">model.Neq = 3; </div></div><!-- fragment --><h2><a class="anchor" id="parameters"></a>
Parameters</h2>
<p>Create the respective symbolic variables. The name of the symbolic variable can be chosen arbitrarily.</p>
<div class="fragment"><div class="line">syms p1 p2 p3 p4 p5 p6 p7 p8 </div></div><!-- fragment --><p>Create the parameters vector of parameters to be considered for identifiability.</p>
<div class="fragment"><div class="line">model.Par = [p1 p2 p3 p4 p5 p6 p7 p8]; </div></div><!-- fragment --><p>Specify the number of parameters to be considered for identifiability.</p>
<div class="fragment"><div class="line">model.Npar = 8; </div></div><!-- fragment --><h2><a class="anchor" id="equtions"></a>
Equations</h2>
<p>Define the vector field of the model.</p>
<div class="fragment"><div class="line">A1 = -p4*x1+p1/(p2+x3^p3);</div><div class="line">A2 = p5*x1-p6*x2;</div><div class="line">A3 = p7*x2-p8*x3;</div><div class="line">model.F=[A1 A2 A3];</div></div><!-- fragment --><h2><a class="anchor" id="controls"></a>
Controls</h2>
<p>Define the controls.</p>
<div class="fragment"><div class="line">g1=0;</div><div class="line">g2=0;</div><div class="line">g3=0;</div><div class="line">model.G=[g1 g2 g3];</div></div><!-- fragment --><p>Define the number of controls.</p>
<div class="fragment"><div class="line">model.Noc = 0; </div></div><!-- fragment --><p>The matrix G has as many columns as there are state variables and as many rows as there are inputs.</p>
<h2><a class="anchor" id="obserables"></a>
Observables</h2>
<p>Define the observables.</p>
<div class="fragment"><div class="line">h1 = x1;</div><div class="line">h2 = x2;</div><div class="line">h3 = x3;</div><div class="line">model.H = [h1 h2 h3];</div></div><!-- fragment --><p>Define the number of obserables.</p>
<div class="fragment"><div class="line">model.Nobs = 1; </div></div><!-- fragment --><h2><a class="anchor" id="ic"></a>
Initial Conditions</h2>
<p>Define the initial conditions. The initial conditions can be fixed numerical values or a function of model parameters.</p>
<div class="fragment"><div class="line">model.IC = [0.3 0.9 1.3];</div></div><!-- fragment --><h1><a class="anchor" id="analysis"></a>
Model Analysis</h1>
<p>The structural identifiability of the model can be analyzed by calling the MATLAB function genssiMain. The first parameter of genssiMain is the name of the model, and the second parameter is the format. If the format is absent, the model is assumed to be a function, as described above. If it is equal to 'mat', the model is assumed to be a MATLAB file with name Modelname.mat (e.g. Goodwin.mat) and containing the model struct.</p>
<div class="fragment"><div class="line"><a class="code" href="genssi_main_8m.html#aac78e2620e69e2ecf610a2526a32c7fb">genssiMain</a>(<span class="stringliteral">&#39;Goodwin&#39;</span>)</div></div><!-- fragment --><p>The function genssiMain will call the model function or load the .mat file, which puts the model struct in memory. After that, it will call all other GenSSI functions required to analyze the model. The results will be put into a directory created using the name of the model and the next available run number, for example GenSSI/Results/Goodwin/run3.</p>
<p>The results include a results file, with the name 'model_information.txt', and all identifiiability tableaus created during analysis, in MATLAB format, for example 'Figure1.fig'.</p>
<p>It is not necessary to analyze the identifiability tableaus unless you are looking for deeper insight into the structure of the model and its identifiability characteristics. They are described in more detail in:</p>
<ul>
<li>Chis, O.-T., J. R. Banga, et al. (2011). "Structural Identifiability of Systems Biology Models: A Critical Comparison of Methods." PLoS ONE 6(11): e27755.</li>
<li>Balsa-Canto, E., A. Alonso, et al. (2010). "An iterative identification procedure for dynamic modeling of biochemical networks." BMC Syst Biol 4(1): 11.</li>
</ul>
<p>The identifiability tableaus are binary versions of the Jacobian matrix, and help in determining identifiability of parameters during the analysis process. Columns consisting solely of zeros indicate that the respective parameter cannot be identified. Rows consisting solely of zeros provide no information and are deleted. Rows consisting of a single one indicate identifiability, and rows consisting or two or more ones indicate that there are relations that might be solved to provide identifiability.</p>
<p>The results file 'model_information.txt' contains the main output of the identifiability analysis of GenSSI. It begins by documenting the primary features of the model and ends by stating which parameters are locally or globally identifiable. The middle part, which can be skipped during a first reading, documents the steps taken during analysis and which relations were solved to determine identifiability of individual parameters. Here is an example of the final part of this file for the Goodwin model used as an example in this reference manual:</p>
<div class="fragment"><div class="line"> -----&gt; THE MODEL IS STRUCTURALLY LOCALLY IDENTIFIABLE </div><div class="line"></div><div class="line">                                                               </div><div class="line"></div><div class="line">        The structurally globally identifiable parameters are: </div><div class="line"></div><div class="line">            None</div><div class="line"></div><div class="line">        The structurally locally identifiable parameters are: </div><div class="line"></div><div class="line">        [      p1         p2          p4          p5          p6          p7          p8    ]</div><div class="line"></div><div class="line"></div><div class="line">Report results elapsed time: 0.04445</div><div class="line">Total elapsed time: 3.4703</div></div><!-- fragment --><h1><a class="anchor" id="conversion"></a>
Conversion Utilities</h1>
<p>The GenSSI package also includes some functions for converting models from one format to another.</p>
<h2><a class="anchor" id="poly"></a>
Convert to Polynomial Format</h2>
<div class="fragment"><div class="line"><a class="code" href="genssi_to_polynomial_8m.html#acef0ff085917e1375d0fc2b6feed0722">genssiToPolynomial</a>(modelNameIn,modelNameOut) </div></div><!-- fragment --><p>genssiToPolynomial converts a model, expressed in terms of rational expressions, to pure polynomial format. This increases the number of state variables, but can sometimes significantly reduce the computational overhead for analyzing the model.</p>
<p>modeNameIn: name of model to be converted (string).</p>
<p>modelNameOut: name of model to be created (string).</p>
<h2><a class="anchor" id="multiexp"></a>
Create Multi-Experiment Model</h2>
<div class="fragment"><div class="line"><a class="code" href="genssi_multi_experiment_8m.html#a99c14a4d68fa9a17610a21cc6ead7e30">genssiMultiExperiment</a>(modelNameIn,fileFormat,mExDef,modelNameOut) </div></div><!-- fragment --><p>genssiMultiExperiment converts a GenSSI model to a new GenSSI model based on a multi-experiment definition.</p>
<p>modelNameIn: the name of the input model (a string).</p>
<p>fileFormat: either 'function' (default), if the model is a MATLAB function, or 'mat', if the model is a .mat file.</p>
<p>mExDef: the name of a multi-experiment definition file (string).</p>
<p>modelNameOut: the name of the output model (a string).</p>
<p>GenSSI 2.0 supports structural identifiability analysis for systems with multiple experimental conditions. As the information content of an individual experiment is often limited, in most applications, multiple experiments are performed. These experiments usually differ in the experimental conditions, meaning that different initial conditions, perturbations or control inputs are used. This increases the amount of information and thereby the identifiability of the parameters.</p>
<p>To perform structural identifiability analysis for problems with multiple experimental conditions, GenSSI provides the MATLAB function genssiMulitEpxeriment, which generates a (multi-experiment) GenSSI model for a single experimental condition and a description of the changes in the experimental conditions.</p>
<p>To illustrate the functionality, we considered a model for mRNA transfection, accounting for translation and degradation. The model definition is:</p>
<div class="fragment"><div class="line"><span class="keyword">function</span> model = M1_1_U2()</div><div class="line">    model.Name=&#39;M1_1_U1&#39;;</div><div class="line">    syms  m G d b kTL m0</div><div class="line">    model.Nder=4;</div><div class="line">    model.X=[m G];</div><div class="line">    model.Neq=2;</div><div class="line">    A1=-d*m;</div><div class="line">    A2=0;</div><div class="line">    model.F=[A1 A2];</div><div class="line">    model.G=[0,kTL*m;...</div><div class="line">             0,-b*G];</div><div class="line">    model.Noc=2;</div><div class="line">    h1=G;</div><div class="line">    model.H=[h1];</div><div class="line">    model.Nobs=1;</div><div class="line">    model.IC=[m0 0];</div><div class="line">    model.P=[d b kTL m0];</div><div class="line">    model.Par=[d b kTL m0];</div><div class="line">    model.Npar=4;</div><div class="line">end</div></div><!-- fragment --><p>The variables (model.X) are m (the level of mRNA) and G (the level of GFP, green fluorescent protein), of which only G is observed (model.H). The differential equations (model.F) define degradation of mRNA (-d*m), degradation of GFP (-b*G) and translation of mRNA to GFP (kTL*m). Note that translation and GFP degradation have been defined as controls (model.G).</p>
<p>Based on this model, we define a total of four experimental conditions, in the experiment definition function. The expriments are defined by modifying the controls and the initial conditions. The expriments are:</p>
<p>1) original configuration</p>
<p>2) change in transfection (m0) via IC: The initial concentration of mRNA is changed.</p>
<p>3) change in translation via control u1 = uInh: The rate of translation is changed, for example by treating the cell with CHX (the antiseptic chlorhexidine).</p>
<p>4) change in GFP degradation via control u2 = uDeg: The rate of GFP degradation is changed, for example by using destabilized GFP (d2eGFP) instead of normal GFP (eGFP).</p>
<p>The experiment definition is:</p>
<div class="fragment"><div class="line"><span class="keyword">function</span> multiExp = M1_1_eDef4()</div><div class="line">    multiExp.Name=&#39;M1_1_eDef4&#39;;</div><div class="line">    syms d b kTL m0Exp1</div><div class="line">    multiExp.Nexp=4;</div><div class="line">    multiExp.U = [1,1;...</div><div class="line">                  1,1;...</div><div class="line">                  .5,1;...</div><div class="line">                  1,.75];</div><div class="line">    multiExp.IC = [m0Exp1,0,...</div><div class="line">                   0.5*m0Exp1,0,...</div><div class="line">                   m0Exp1,0,...</div><div class="line">                   m0Exp1,0];</div><div class="line">    multiExp.P=[d,b,kTL,m0Exp1];</div><div class="line">    multiExp.Par=[d,b,kTL,m0Exp1];</div><div class="line">end</div></div><!-- fragment --><p>The number of expriments is coded in multiExp.Nexp=4.</p>
<p>The variable multiExp.U defines the changes in the controls and the variable multiExp.IC defines the changes in the initial conditions. Both of these variables contain one row for each experiment and one column for each state variable. In the first experiment (original configuration), the controls are 1 and the initial mRNA concentration is m0Exp1. In the second expriment (change in transfection), the initial concentration of mRNA is changed. In the third experiment (change in translation), the rate of translation is changed by changing the value of the first control. In the fourth experiment (change in GFP degradation), the rate of GFP degradation is changed by changing the value of the second control.</p>
<p>The original model is converted to the multi-experiment model by means of this line of code:</p>
<div class="fragment"><div class="line"><a class="code" href="genssi_multi_experiment_8m.html#a99c14a4d68fa9a17610a21cc6ead7e30">genssiMultiExperiment</a>(<span class="stringliteral">&#39;M1_1_U2&#39;</span>,<span class="stringliteral">&#39;function&#39;</span>,<span class="stringliteral">&#39;M1_1_eDef4&#39;</span>,<span class="stringliteral">&#39;M1_1_ME4&#39;</span>); </div></div><!-- fragment --><p>The result of the conversion is the following (multi-experiment) model:</p>
<div class="fragment"><div class="line"><span class="keyword">function</span> model = M1_1_ME4()</div><div class="line">    syms mExp1 GExp1 mExp2 GExp2 mExp3 GExp3 mExp4 GExp4</div><div class="line">    syms d b kTL m0Exp1</div><div class="line">    model.Name = &#39;M1_1_ME4&#39;;</div><div class="line">    model.Nder = 4;</div><div class="line">    model.X = [mExp1,GExp1,mExp2,GExp2,mExp3,GExp3,mExp4,GExp4];</div><div class="line">    model.Neq = 8;</div><div class="line">    model.G = [0,0,0,0,0,0,0,0];</div><div class="line">    model.Noc = 0;</div><div class="line">    model.P = [d,b,kTL,m0Exp1];</div><div class="line">    model.Par = [d,b,kTL,m0Exp1];</div><div class="line">    model.Npar = 4;</div><div class="line">    model.IC = [m0Exp1,0,m0Exp1/2,0,m0Exp1,0,m0Exp1,0];</div><div class="line">    model.H = [GExp1,GExp2,GExp3,GExp4];</div><div class="line">    model.Nobs = 4;</div><div class="line">    model.F = [-d*mExp1,...</div><div class="line">               kTL*mExp1 - GExp1*b,...</div><div class="line">               -d*mExp2,...</div><div class="line">               kTL*mExp2 - GExp2*b,...</div><div class="line">               -d*mExp3,...</div><div class="line">               (kTL*mExp3)/2 - GExp3*b,...</div><div class="line">               -d*mExp4,...</div><div class="line">               kTL*mExp4 - (3*GExp4*b)/4];</div><div class="line">end</div></div><!-- fragment --><p>Based on the original 2 state variables and 4 experiments, we now have 2*4=8 state variables (model.X).</p>
<h2><a class="anchor" id="transf"></a>
Transform Model</h2>
<div class="fragment"><div class="line"><a class="code" href="genssi_transformation_8m.html#a00c8981ee764669cf32d736351fbf275">genssiTransformation</a>(modelNameIn,fileFormat,transDef,modelNameOut) </div></div><!-- fragment --><p>genssiTransformation converts a GenSSI model to a new GenSSI model based on a transformation definition.</p>
<p>modelNameIn: the name of the input model (a string).</p>
<p>fileFormat: either 'function' (default), if the model is a MATLAB function, or 'mat', if the model is a .mat file.</p>
<p>transDef: the name of a transformation definition file (string).</p>
<p>modelNameOut: the name of the output model (a string).</p>
<p>When we analyze equations for the purpose of determining identifiability, it is sometimes useful to make two changes. The first change is removing redundant equations, which can reduce the number of state variables and the number of parameters. The second change is rescaling the variables, which can reduce the number of parameters. Both of these changes are supported by genssiTransformation.</p>
<p>We begin with a model for mRNA, including translation and degradation. In contrast with the simpler model used for the multi-experiment conversion (above), this model involves mRNA degradation via the action of an enzyme. The model definition is:</p>
<div class="fragment"><div class="line"><span class="keyword">function</span> model = M2_1_Y1()</div><div class="line">    model.Name=&#39;M2_1_Y1&#39;;</div><div class="line">    syms m G E1 mE d1 d2 d3 b kTL m0 E0</div><div class="line">    model.Nder=8;</div><div class="line">    model.Neq=4;</div><div class="line">    model.Npar=7;</div><div class="line">    model.Noc=0;</div><div class="line">    model.Nobs=1;</div><div class="line">    model.X=[m G E1 mE];</div><div class="line">    A1=-d1*m-d2*m*E1;</div><div class="line">    A2=+kTL*m-b*G;</div><div class="line">    A3=+d3*mE-d2*m*E1;</div><div class="line">    A4=-d3*mE+d2*m*E1;</div><div class="line">    model.F=[A1 A2 A3 A4];</div><div class="line">    g1=0;g2=0;g3=0;g4=0;</div><div class="line">    model.G=[g1 g2 g3 g4];</div><div class="line">    h1=G;</div><div class="line">    model.H=[h1];</div><div class="line">    model.IC=[m0 0 E0 0];    </div><div class="line">    model.P=[d1 d2 d3 b kTL m0 E0];</div><div class="line">    model.Par=[d1 d2 d3 b kTL m0 E0];</div><div class="line">end</div></div><!-- fragment --><p>The state variables in this model (model.X) are mRNA (m), GFP (G), enzyme (E1), and the mRNA-enzyme complex (mE). We have used E1 as the name of the enzyme instead of E since there are cases where MATLAB will treat the symbolic variable E as e or exp(1). The differential equations show mRNA (m) decreasing due to degradation (-d1*m) and decreasing due to complexation (-d2*m*E1). GFP (G) increases due to translation (kTL*m) and decreases due to complexation (-d2*m*E1). The enzyme (E1) decreases due to complexation (-d2*m*E1) and increases due to decomplexation (d3*mE). The change in the complex (mE) is exactly the opposite of the change in the enzyme. As a result of this, we know that E1-E1(0)=-(mE-mE(0)) or, since mE(0), E1-E0+mE=0. In addition, we know that the concentration of GFP always depends on the product of mRNA(0)*kTL, so we will be able to reduce the number of parameters by rescaling (dividing by m0).</p>
<p>With these observations, we can create our transformation definition:</p>
<div class="fragment"><div class="line"><span class="keyword">function</span> transDef = M2_1_tDef()</div><div class="line">    transDef.Name=&#39;M2_1_tDef&#39;;</div><div class="line">    syms m G E1 mE m0 E0</div><div class="line">    syms mdm0 E1dm0</div><div class="line">    syms d1 d2 d3 b kTL</div><div class="line">    syms d2tm0 kTLtm0 E0dm0</div><div class="line">    transDef.Transformation = [m/m0;G;E1/m0];</div><div class="line">    transDef.Constraint = [E1-E0+mE];</div><div class="line">    transDef.P = [d1,d2tm0,d3,b,kTLtm0,E0dm0];</div><div class="line">    transDef.Par = [d1,d2tm0,d3,b,kTLtm0,E0dm0];</div><div class="line">    syms mnew Gnew E1new</div><div class="line">    transDef.stateSubs = [mdm0,mnew;...</div><div class="line">                          G,Gnew;...</div><div class="line">                          E1dm0,E1new];</div><div class="line">    transDef.parSubs = [d2*m0,d2tm0;...</div><div class="line">                        kTL*m0,kTLtm0;...</div><div class="line">                        E0/m0,E0dm0];</div><div class="line">end</div></div><!-- fragment --><p>The transformation is defined by two variables. The first, transDef.Transformation, defines the rescaling. It contains one entry for each element of the final state vector. Since we are converting a model with 4 state variables to 3, this contains 3 elements. The second part of the definition is the constraint, transDef.Constraint. This will be equated to zero during the transformation, so it is E1-E0+mE=0, or, equivalently, E1-E1(0)=-(mE-mE(0)). The variable transDef.Constraint can contain multiple constraints, separated by a semicolon. Finally, there are two optional definitions of substitutions. They contain a variable number of rows, each of which is a substitution, or change of names. During the transformation process, new variables are created for the state vector and the parameters, and the names are changed via the rules "*"-&gt;"t" (for "times") and "/"-&gt;"d" (for "divided by"). These names can be considered as suggestions for the new names, and the user can override them with the stateSubs and parSubs definitions. For example, mdm0 is replaced by mnew in the state vector, and d2*m0 is replaced by d2tm0 in the parameters. It is considered good practice to leave these 2 definitions out the first time the transformation is run, and then add them in later in order to gain more control over the naming.</p>
<p>This transformation is started by running the following line of code:</p>
<div class="fragment"><div class="line"><a class="code" href="genssi_transformation_8m.html#a00c8981ee764669cf32d736351fbf275">genssiTransformation</a>(<span class="stringliteral">&#39;M2_1_Y1&#39;</span>,<span class="stringliteral">&#39;function&#39;</span>,<span class="stringliteral">&#39;M2_1_tDef&#39;</span>,<span class="stringliteral">&#39;M2_2_test&#39;</span>); </div></div><!-- fragment --><p>The result of the transformation is the following new model:</p>
<div class="fragment"><div class="line"><span class="keyword">function</span> model = M2_2_test()</div><div class="line">    syms mnew Gnew E1new</div><div class="line">    syms d1 d2tm0 d3 b kTLtm0 E0dm0</div><div class="line">    model.Name = &#39;M2_2_test&#39;;</div><div class="line">    model.Nder = 8;</div><div class="line">    model.X = [mnew,Gnew,E1new];</div><div class="line">    model.Neq = 3;</div><div class="line">    model.G = [0,0,0,0];</div><div class="line">    model.Noc = 0;</div><div class="line">    model.P = [d1,d2tm0,d3,b,kTLtm0,E0dm0];</div><div class="line">    model.Par = [d1,d2tm0,d3,b,kTLtm0,E0dm0];</div><div class="line">    model.Npar = 6;</div><div class="line">    model.IC = [1,0,E0dm0];</div><div class="line">    model.H = [Gnew];</div><div class="line">    model.Nobs = 1;</div><div class="line">    model.F = [- d1*mnew - E1new*d2tm0*mnew,...</div><div class="line">               kTLtm0*mnew - Gnew*b,...</div><div class="line">               (E0*d3)/m0 - E1new*d2tm0*mnew - E1new*d3];</div><div class="line">end</div></div><!-- fragment --><p>In this transformed model, the new state variables are mnew, Gnew, and E1new, based on the definition transDef.stateSubs.</p>
<h2><a class="anchor" id="toamici"></a>
Export to AMICI Format</h2>
<div class="fragment"><div class="line"><a class="code" href="genssi_to_amici_8m.html#a317b8cb9b241f23b1d8c0da3b37e63ee">genssiToAmici</a>(modelNameIn,modelNameOut) </div></div><!-- fragment --><p>genssiToAMICI converts a GenSSI model to AMICI format. The AMICI package uses Sundials CVODES and IDAS to efficiently solve ODEs from within MATLAB. It is available at <a href="https://github.com/AMICI-developer/AMICI">https://github.com/AMICI-developer/AMICI</a>.</p>
<p>modelNameIn: name of the GenSSI model (string).</p>
<p>modelNameOut: name of the AMICI model (string).</p>
<p>This is an important feature, since AMICI supports SBML import, thereby effectively providing GenSSI with an SBML import.</p>
<p>Note: There are limitations to this conversion. The GenSSI model contains a list of parameters to be considered for analysis, but AMICI needs a "sym" statement containing a list of all parameters used by the model. It may be necessary to manually edit the AMICI model after conversion. In order to avoid this, the GenSSI model can contain a variable model.P, containing all parameters (model.Par only contains the parameters to be considered for identifiability).</p>
<h2><a class="anchor" id="fromamici"></a>
Import from AMICI Format (and SBML Models)</h2>
<div class="fragment"><div class="line"><a class="code" href="genssi_from_amici_8m.html#aa177acfd2eae54685d2487430b93091e">genssiFromAmici</a>(modelNameIn,modelNameOut) </div></div><!-- fragment --><p>genssiFromAMICI converts an AMICI model to GenSSI format.</p>
<p>modelNameIn: name of the AMICI model (string).</p>
<p>modelNameOut: name of the GenSSI model (string).</p>
<p>Note: There are limitations to this conversion. The AMICI model contains a list of all parameters used by the model, but GenSSI needs a list of parameters to be considered for analysis. In addition, the GenSSI model created by the conversion contains default values for parameters such as the number of derivatives. It may be necessary to manually edit the GenSSI model after conversion.</p>
<h2><a class="anchor" id="structtosource"></a>
Convert from Model Structure to Model Source Format</h2>
<div class="fragment"><div class="line"><a class="code" href="genssi_struct_to_source_8m.html#a89e0f25ee6214137a181974078dedd04">genssiStructToSource</a>(model) </div></div><!-- fragment --><div class="fragment"><div class="line"><a class="code" href="amici_struct_to_source_8m.html#a5c714bc9158f2f1899f751a37e0ae827">amiciStructToSource</a>(model) </div></div><!-- fragment --><p>genssiStructToSource reads the GenSSI model struct and converts it to source format (MATLAB function definition), and amiciStructToSource does the same for AMICI models. In general, the source format is more convenient for smaller models, since it is easier to modify, but the struct format, typically saved in a MATLAB file (e.g. Goodwin.mat) is more convenient for large models, since it does not require editing of long lines of code.</p>
<p>model: model definition (struct). </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu Feb 2 2017 14:41:14 for GenSSI by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
